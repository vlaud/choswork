# [게임 제목]  - Unity 공포 게임 프로젝트

## 목차
- [프로젝트 요약](#한눈에-보는-프로젝트-요약)
- [프로젝트 개요](#프로젝트-개요)
- [사용 기술 스택](#사용-기술-스택)
- [주요 기능](#주요-기능)
- [설계/개발 전략](#주요-설계개발-전략)
- [학습 및 성장 포인트](#학습-및-성장-포인트)
- [향후 계획](#향후-계획)
- [프로젝트 구조](#프로젝트-구조-요약)

## 한눈에 보는 프로젝트 요약

* Unity 기반 3D 공포 게임 (개인 제작)
* FSM 기반 AI 추적 시스템, 카메라/사운드 연출 포함
* 데모 영상 👉 [YouTube 링크](https://youtu.be/3l61qr2uoDs?si=6gp0NSIAj7bBtbh3)

<details>
  <summary>🖼️ 스크린샷 보기</summary>
  > 🔧 현재 이미지 캡처 작업 중입니다. 곧 추가 예정입니다.
  
  <img src="Assets/Images/demo1.png" alt="게임 플레이 화면" width="600"/>
  <!-- 추가 이미지도 여기에 -->
</details>

## 프로젝트 개요

* **프로젝트 이름**: `choswork` (가제)
* **개발 유형**: 개인 프로젝트  
* **개발 기간**: 2022.12 \~ (진행 중)

* **핵심 목적 및 목표**:
  * Unity 엔진 기반으로 실제 플레이 가능한 공포 게임을 직접 제작하여 실전 개발 역량을 입증하고자 했습니다.
  * 몰입감 있는 공포 연출과 AI 추적 시스템 구현을 통해 연출 및 실시간 로직 처리 능력을 검증했습니다.
  * Git 브랜치 전략 수립, 코드 리팩토링, 이슈 관리 워크플로우를 자체 시뮬레이션했습니다.
  
* **선택 이유**:
  * 공포 장르의 연출적 난이도와 기술적 구현 요소가 복합되어 있어, 클라이언트 역량을 폭넓게 실험할 수 있는 주제라고 판단했습니다.
  * 단순 구현을 넘어 ‘몰입’과 ‘게임성’ 모두를 설계/개발할 수 있는 소재로서 적합하다고 생각했습니다.

---

## 사용 기술 스택

* **엔진**: Unity (버전 명시 예: 2021.3 LTS)
* **언어**: C#
* **툴 및 서비스**:
  * Git / GitHub
  * Unity Profiler 및 Debugging 도구 활용

* **활용 기술 및 패턴**:
  * **AI 시스템**: FSM (Finite State Machine), C#
  * **UI/카메라 시스템**: 이벤트 버스, 커맨드 패턴, 코루틴
  * **사운드 시스템**: 상황 기반 BGM 전환, Singleton 기반 AudioManager
  * **패턴 사용**: 싱글톤, 옵저버, 이벤트 버스, 상태, 커맨드, 오브젝트 풀 등

---
## 주요 기능
1. **AI 추적 시스템 (FSM)**

   * 플레이어가 시야에 들어오면 추적, 소리에 반응해 탐색하는 적 AI
   * Switch 기반 FSM 구조로 상태 관리 구현
   * 💡 *확장 가능성 고려: Scriptable FSM 구조로의 리팩토링 가능성 열어둠*

2. **몰입형 연출 기능**

   * 1인칭/3인칭 카메라 전환
   * 적에게 맞을 때 카메라 흔들림 효과 적용
   * 사망 시 페이드아웃 후 타이틀 화면 전환

3. **사운드 연출 시스템**

   * 긴박한 상황에서 BGM 자동 전환
   * 비상 상태가 해소되면 평상시 BGM으로 복귀
   * BGM 및 SFX 전환은 Singleton 기반의 Audio Manager로 제어

4. **타이틀 연출**

   * 마우스 움직임에 반응하는 타이틀 카메라
   * 깜빡이는 형광등 연출로 분위기 조성
     
---

## 주요 설계/개발 전략

* **경량 FSM 설계**로 AI 상태 전이 구현
* Unity의 `Animator`, `Coroutines`를 활용한 카메라/이펙트 제어
* Scene 내 상태 전이를 `GameManager`, `UIManager`, `AudioManager`로 명확히 분리하여 책임 영역을 구분
* 확장성과 테스트 용이성을 고려한 모듈 구조 유지
---
## 학습 및 성장 포인트

* Unity 엔진의 구조 및 MonoBehaviour 생명주기, Input 이벤트 흐름에 대한 이해를 기반으로 게임 시스템을 설계
* 상태 전이, UI 연동, 입력 처리 등 복잡한 로직을 디자인 패턴과 이벤트 기반 설계로 모듈화
* 디버깅, 메모리 관리, 인스펙터 커스터마이징 등 Unity 내부 도구와 API를 적극적으로 활용
* 실무 시뮬레이션을 통해 Git 브랜치 전략, 코드 리팩토링, 커밋 관리 습관화

### 🎯 구체적인 성장 사례

#### 🎮 상태 전이 충돌 문제 해결

* **문제**: ESC 키로 게임 재개/일시정지, 옵션 진입/복귀 등 다양한 UI 상태가 얽히면서 입력 충돌 발생
* **해결**: `커맨드 패턴`을 도입해 각 UI 상태별로 ESC 키에 할당된 동작(Command)을 클래스화하여 유연하게 교체
* **교훈**: 단일 입력이 여러 동작을 트리거할 때에도 **단일 책임 원칙**을 준수하면, 상태별 로직 교체와 디버깅이 훨씬 수월해진다

#### 📸 UI 연동 카메라 상태 제어

* **문제**: I 키로 인벤토리를 열면서, 동시에 캐릭터가 카메라 정면을 바라보도록 조작해야 하는 요구사항 발생
* **해결**: 이벤트 버스와 커맨드 패턴을 조합하여, UI 상태 변화 → 카메라 상태 예약 → UI 종료 시 카메라 적용 흐름 구현
* **교훈**: 복합적인 입력/출력 흐름은 **이벤트 드리븐** 구조로 분리하면, 기능 추가나 수정 시 코드 의존도를 크게 낮출 수 있다

#### 🔁 다중 시스템 반응 문제 해결

* **문제**: 하나의 입력(예: I 키)에 대해 여러 클래스(인벤토리, 카메라, 플레이어 등)가 동시에 반응해야 함
* **해결**: 직접 참조 대신 `이벤트 버스` 패턴을 활용하여 느슨한 결합으로 클래스 간 의존성 해소
* **교훈**: 이벤트 필터링을 통해 특정 구독자만 반응하게 설계하면, 시스템 확장성과 유지보수성이 크게 개선된다

#### 🎲 난수 중복 제거 최적화

* **문제**: 중복 없는 랜덤 생성에서 기존에는 리스트 생성 후 `Remove` 방식으로 처리하여 **성능 저하**와 **코드 복잡도** 문제 발생
* **해결**: `Fisher–Yates Shuffle` 알고리즘을 도입해 한 번의 셔플로 중복 없는 난수 리스트를 효율적으로 생성
* **교훈**: 표준 알고리즘을 활용하면 복잡한 로직을 간결하고 효율적으로 구현할 수 있으며, **알고리즘 선택의 중요성**을 깨달았다

#### 🖱️ 커서 상태 일관성 문제 해결

* **문제**: ESC 키나 인벤토리 토글 시 커서가 사라지지 않거나, 반대로 의도치 않게 가시 상태가 유지되는 버그 발생
* **해결**: 커서 노출 상태를 `상태 플래그 집합`으로 통합 관리하여 한 곳에서만 토글하도록 구조화(추후 비트마스크로 리팩토링 예정)
* **교훈**: UI 관련 상태는 **중앙 집중식 관리**가 필수이며, 플래그 기반 접근으로 상태 전이를 명확히 정의해야 안정성이 보장된다

#### 🌀 코루틴 관리 최적화

* **문제**: 매번 `Coroutine` 시작/중단을 직접 관리하다 보니, 중복 호출 및 추적이 어려워져 **타이밍 버그**가 빈번히 발생
* **해결**: `CoroutineRunner` 싱글톤 클래스 도입 및 딕셔너리 기반 태그 관리 방식 구현으로, 태그별 코루틴을 일괄 제어
* **교훈**: 반복되는 비동기 로직은 **추상화된 매니저**로 통합 관리해야, 의도치 않은 중복 실행을 방지하고 유지보수를 용이하게 할 수 있다

#### 🔗 의존성 구조 개선 및 인스펙터 편의성 향상

* **문제**: 클래스 간 직접 참조로 인해 구조가 얽히고, 인스펙터 상에서 연결을 시각적으로 파악하기 어려움
* **해결**: `옵저버 패턴`과 `인터페이스 홀더<T>`를 사용해 느슨한 결합과 인스펙터 연동을 모두 확보, `PropertyDrawer`로 커스텀 UI 구현
* **교훈**: 코드 설계뿐만 아니라 **에디터 경험**도 고려해야 협업 효율이 올라가며, 에디터 확장을 통해 생산성을 높일 수 있다

#### 📑 딕셔너리 직렬화 필요 해결

* **문제**: Unity 인스펙터 상에서 딕셔너리 자료형이 기본으로 노출되지 않아 편집이 불가능
* **해결**: `SerializableDictionary<TKey, TValue>` 유틸 클래스를 구현하여 딕셔너리를 인스펙터에 노출
* **교훈**: Unity의 기본 한계를 **커스텀 직렬화**로 보완하면, 에디터 툴 활용성이 크게 강화된다는 것을 배웠다


#### 🧭 자동 맵 생성 및 동적 네비게이션 적용

* **문제**: 수작업으로 맵을 생성하는 비효율성과 반복성을 해소하고, 매 플레이마다 새로운 구조를 제공하고 싶음
* **해결**:
  1. **3D DFS 기반 자동 미로 생성 알고리즘**으로 상/하/좌/우 이동이 가능한 3차원 빌딩 구조 자동 생성
  2. `NavMeshSurface.BuildNavMesh()`를 게임 시작 시 호출해 **런타임 네비메시**를 동적으로 빌드
* **교훈**: **런타임 시스템 생성**을 도입하면 리플레이성과 확장성을 대폭 향상시킬 수 있으며, 반복 작업을 자동화하는 툴 제작의 가치를 깨달았다

---

## 향후 계획

### ✅ 단기 목표 (1\~2주 이내)

* **FSM 구조 리팩토링 시작**

  * 기존 FSM 일부를 **ScriptableObject 기반 상태 관리**로 전환 시도
  * 전체 전환이 아닌, **1\~2개 상태만 시범 리팩토링**하여 구조 감 잡기

* **WebGL 빌드 테스트 및 리소스 최적화**

  * 압축 설정, UI/씬 로딩 최적화 등으로 빌드 성공 여부 검증
  * 외부 배포 기반 마련 → 포트폴리오 활용도 향상

---

### 🚧 중기 목표 (1개월 이내)

* **컷씬 연출 도입 (Unity Timeline 활용)**

  * 짧은 오프닝/사망 시퀀스 등 **연출 타이밍 기반 장면 구성** 실습

* **유닛 테스트 및 디버깅 로깅 체계화**

  * 핵심 클래스 (AI, UI Manager 등) 중심으로 유닛 테스트 설계
  * `Debug.Log` 기반 → 조건별 컬러 로깅/파일 기록 등 점진적 개선

* **비트마스크 상태 관리 개선**

  * 상태 플래그 집합을 **비트 연산 기반 관리**로 최적화
  * 커서, UI, 입력 등의 상태 충돌 감소 및 디버깅 가시성 향상

---

### 🧠 장기 목표 (2\~3개월 이내)

* **UI/UX 전반 개선 및 반응형 설계 적용**

  * 폰트, 색상, 애니메이션 등 **사용자 경험 관점의 연출 강화**
  * WebGL 및 다양한 해상도에 대응하는 인터페이스 구조 정비

* **제너릭 옵저버 패턴 및 의존성 주입 적용**

  * 특정 이벤트 및 UI 동기화 구조를 **제너릭 + 옵저버 패턴**으로 리팩토링
  * **직접 참조 제거 및 테스트 용이성 확보**

* **외부 배포 및 피드백 수집**

  * WebGL 버전 외부 공유
  * 커뮤니티, 커리어 플랫폼, 지인 등을 통한 실제 피드백 확보


---

## 프로젝트 구조 (요약)

```plaintext
📁 Choswork/
├─ Assets/
│  ├─ Scripts/
│  │  ├─ Base/
│  │  ├─ Camera/
│  │  ├─ Commands/
│  │  ├─ EventBus/
│  │  └─ UI/
│  ├─ Scenes/
│  ├─ Resources/
│  └─ AudioClips/
└─ README.md
```
---

*작성일: 2025.05.22*
*작성자: 동현 (Unity 클라이언트 개발자 지망생)*

---
